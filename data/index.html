
 <html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset='UTF-8'>
<style>
    body {
        font-family: Arial, sans-serif;
        background-color: #E1EAF0;
        color: #333;
        margin: 0;
        padding: 20px;
    }
    
        #downloadLink {
      display: none;
      margin-top: 10px;
    }
    #copyMessage {
      display: none;
      margin-top: 10px;
      color: green;
    }

    h1,
    h2 {
        color: #444;
    }
    
    #current-value-label {
    transition: top 0.5s, left 0.5s; /* Плавное перемещение лейбла */
	}

    button {
        font-size: 13px;
        padding: 5px 10px;
        /* Отступы внутри кнопки */
        border: 1px solid gray;
        border-radius: 10px;
        background-color: rgba(173, 216, 230, 0.5);
        color: black;
        box-shadow: 0 4px 6px rgba(206, 183, 183, 0.1);
        transition: all 0.3s ease;
        /* Плавное изменение стилей при наведении */
        cursor: pointer;
    }
    
        .relay-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .relay-description {
        width: 180px;
        text-align: left;
    }
    .relay-controls {
        margin-right: 10px;
    }
    .relay-controls button {
        margin-right: 5px;
    }
    .relay-state, .relay-mode {
        margin-left: 10px;
    }

    input[type="radio"] {
        margin-right: 10px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"] {
        width: 250px;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid #757575;
        border-radius: 10px;
        font-size: 16px;
    }

    /* Унифицированные стили для текстовых полей */
    input[type="text"],
    input[type="number"],
    input[type="date"],
    input[type="time"] {
        border: 1px solid #ccc;
        padding: 5px;
        font-size: 16px;
    }

    label {
        display: block;
        margin-bottom: 5px;
    }

    .tablinks {
        padding: 8px 5px;
        margin-right: 6px;
        background-color: rgba(173, 216, 230, 0.5);
        transition: background-color 0.3s ease;
    }

    .butScan {
        padding: 8px 2px;
        margin-bottom: 8px;
        width: 150px;
        height: 35px;
    }

    .butinput {
        padding: 8px 2px;
        margin-bottom: 8px;
        width: 66px;
        height: 35px;
    }

    .checkbox-container,
    .checkbox-container-inline {
        display: flex;
        align-items: center;
    }

    .turn-off-power-limit .checkbox-container {
        margin-left: auto;
    }

    .checkbox-container {
        display: flex;
        align-items: center;
        margin-left: 10px;
    }

    .checkbox-label-container {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .checkbox-container {
        display: flex;
        align-items: center;
    }

    .checkbox-container label {
        margin-left: 5px;
    }

    .checkbox-container input[type="checkbox"] {
        width: 30px;
        height: 30px;
    }

    #imageContainer {
        width: 100%;
        display: flex;
        justify-content: center;
    }

    #squareImage {
        width: 100%;
        height: auto;
        max-width: 100%;
        object-fit: cover;
    }

    .container-TempSmoothly {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    /* Стили для колибровки */
    /* Стили для контейнера калибровки */
    .calibration-container {
        margin-top: 20px;
    }

    .upper-limit,
    .lower-limit {
        margin-top: 10px;
    }

    .upper-limit label,
    .lower-limit label {
        margin-right: 10px;
    }

    .upper-limit button,
    .lower-limit button {
        margin-right: 5px;
    }

    .calibration-container {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

    .calibration-container label {
        margin-right: 10px;
    }

    #calibrationButton {
        margin-bottom: 10px;
    }

    .upper-limit,
    .lower-limit {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .upper-limit button,
    .lower-limit button {
        margin-left: 5px;
    }

    .switch-label {
        margin-left: 10px;
    }
    
.input-group-calibration {
    display: block; /* Изменено с flex на block */
    margin-bottom: 10px;
}

.input-group-calibration label {
    display: block; /* Добавлено для того чтобы label тоже занимал всю ширину своего контейнера */
    margin-bottom: 5px; /* Добавлен отступ снизу для label */
}

.input-group-calibration input[type="number"] {
    width: 100px;
    padding: 5px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-bottom: 10px; /* Добавлен отступ снизу для input */
}

.info-display {
    display: flex;
    flex-direction: column;
}

.info-display label {
    margin: 5px 0;
}

    .input-group-temperature {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .input-group-temperature label {
        margin-right: 10px;
    }

    .input-group-temperature input[type="number"] {
        width: 100px;
        padding: 5px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-right: 10px;
    }

    .input-group-temperature input[type="checkbox"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    .radio-container {
        display: flex;
        align-items: center;
        margin-top: 10px;
    }

    .radio-container input[type="radio"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    .radio-container label {
        margin-right: 15px;
    }

    /* Стили для текстовых полей времени */
    input[type="time"] {
        width: 100px;
    }

    .radio-container {
        display: flex;
        align-items: center;
        margin-top: 10px;
    }

    .radio-container input[type="radio"] {
        margin-right: 5px;
    }

    .radio-container label {
        margin-right: 20px;
    }

    .interval-container {
        display: flex;
        flex-direction: column;
    }

    .input-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .input-group label {
        margin-right: 10px;
    }

    .input-group input[type="checkbox"] {
        margin-left: 10px;
        margin-right: 5px;
    }

    input[type="time"],
    input[type="date"] {
        padding: 5px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 5px;
        margin-right: 10px;
    }

    /* Стили для слайдера */
    .slider-container input[type="range"] {
        width: 300px;
        display: inline-block;
        margin-right: 10px;
    }

    .slider-container {
        display: flex;
        align-items: center;

    }

    .slider-container input[type="range"] {
        width: 300px;
        display: inline-block;
        width: 380px;
        height: 30px;
    }

    .slider-container label {
        display: flex;
        align-items: center;
        margin-left: 5px;
    }

    .time-container {
        display: flex;
        align-items: left;
        margin-bottom: 10px;
        justify-content: flex-start;

    }

    .time-container label {
        margin-right: 10px;
    }

    .time-container input[type="number"] {
        width: 80px;
        padding: 5px;
        font-size: 16px;
        text-align: center;
        margin-right: 30px;
        box-sizing: border-box;
    }

    .time-container input[type="checkbox"] {
        margin-left: 30px;
    }

    .container {
        margin-bottom: 20px;
        /* Расстояние между контейнерами */
        max-width: 450px;
        margin: 0;
        background-color: #F0F2F5;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        justify-content: space-between;
        align-items: center;
    }

    .radio-label {
        display: inline-flex;
        align-items: center;
        margin-right: 10px;
    }

    .section {
        margin-bottom: 20px;
    }

    button:hover {
        background: linear-gradient(to bottom, #5aafd5, #458dbb);
    }

    /* Стили для состояния нажатия на кнопку */
    button:active {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        /* Уменьшаем тень при нажатии */
    }

    .tablinks:hover,
    .tablinks.active {
        background: linear-gradient(to bottom, #5aafd5, #458dbb);
    }

    .tab {
        display: none;
    }

    .tab.active {
        display: block;
    }

    .hidden {
        display: none;
    }

    .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }

    .switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
    }

    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }

    input:checked+.slider {
        background-color: #2196F3;
    }

    input:checked+.slider:before {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
    }

    /* Rounded sliders */
    .slider.round {
        border-radius: 34px;
    }

    .slider.round:before {
        border-radius: 50%;
    }
</style>
</head>
<body>
<div style="display: flex; align-items: center; justify-content: space-between;">
    <h1>Kolibri WiFi Manager</h1>
    <button onclick="getStatus()"> ℹ️ </button>
  </div>
  
  <div id="status"></div>
  <div id="statusTelegram"></div> 
	<br>
  <div>
    <button class="tablinks" onclick="openTab(event, 'WiFi')" id="defaultOpen">Настройка WiFi</button>
    <button class="tablinks" onclick="openTab(event, 'Telegram')">Настройка Telegram бота</button>
    <button class="tablinks" onclick="openTab(event, 'Control')">Управление</button>
  </div>

  <div id="WiFi" class="tab active">
    <h2>Настройка подключения WiFi</h2>
    <label>
      <input type="radio" id="client" name="mode" value="client" onchange="toggleMode()"> Клиент
    </label>
    <label>
      <input type="radio" id="is_ap" name="mode" value="is_ap" checked onchange="toggleMode()"> Точка доступа
    </label>
    <div id="clientSettings">
      <label>
        <input type="radio" id="dhcp" name="ip_mode" value="dhcp" checked onchange="toggleIPMode()"> DHCP
      </label>
      <label>
        <input type="radio" id="static" name="ip_mode" value="static" onchange="toggleIPMode()"> Статический IP
      </label>
    </div>
    
    <div id="staticIPSettings" class="hidden">
      <label for="static_ip">IP адрес:</label>
      <input type="text" id="static_ip" name="static_ip"><br>
      <label for="gateway">Шлюз:</label>
      <input type="text" id="gateway" name="gateway"><br>
      <label for="subnet">Маска подсети:</label>
      <input type="text" id="subnet" name="subnet"><br>
      <label for="dns">DNS:</label>
      <input type="text" id="dns" name="dns"><br>
      
    </div>
   <button class="butScan" onclick="scanWiFi()" id="scanButton">Сканировать WiFi сети</button>
   
<div id="networks"></div>
<form id="connectForm" style="display:none;">
    <h2>Подключиться к WiFi</h2>
    <label for="ssid">SSID:</label>
    <input type="text" id="ssid" name="ssid"><br>
    <label for="password">Пароль:</label>
    <input type="text" id="password" name="password"><br>
    <!-- <button type="button" onclick="connectWiFi()">Подключиться</button> -->
</form>
  </div>
  
<div id="apSettings" class="hidden">
    <h2>Настройка точки доступа</h2>
    <form>
        <label for="ap_ssid">SSID точки доступа:</label>
        <input type="text" id="ap_ssid" name="ap_ssid" value="KolibriAP"><br>
        <label for="ap_password">Пароль точки доступа:</label>
        <input type="text" id="ap_password" name="ap_password"><br>
        <label for="ap_ip">IP адрес точки доступа:</label>
        <input type="text" id="ap_ip" name="ap_ip" value="192.168.1.1"><br>
        <!-- <button type="button" onclick="setAccessPoint()">Установить точку доступа</button> -->
    </form>
</div>

  <div id="Telegram" class="tab">
    <h2>Настройка Telegram бота</h2>

         <div class="input-group">
        <label for="isTelegramOnCheckbox">Использовать телеграм</label>
        <label class="switch">
            <input type="checkbox" class="switchCheckbox" id="isTelegramOn" checked>
            <span class="slider round"></span>
        </label>
       </div>

<form id="telegramForm" onsubmit="return false">
    <label for="botId">ID телеграм бота:</label>
    <input type="text" id="botId" name="botId" style="width: 250px;">
    
    <button type="button" onclick="setBotId()">Задать</button>
    
    <label for="userId">ID пользователя:</label>
    <input type="text" id="userId" name="userId">
    
    <button type="button" onclick="addUser()">Добавить</button><br><br>

    <div id="userTable" class="hidden">
        <h2>Добавленные пользователи</h2>
        <table>
            <thead>
                <tr>
                    <th>ID пользователя</th>
                    <th>Чтение</th>
                    <th>Управление</th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="userList">
                <!-- Здесь будут отображаться добавленные пользователи -->
            </tbody>
        </table>
    </div>
   
	</form>

  </div>

<form id="deviceSettingsForm" >

<div id="Control" class="tab">
  <h2>Управление</h2>

  <!-- Форма для  устройства -->
<form id="addDeviceForm">
    <!-- control.html -->
    <div class="relay-row" data-relay="Скважинный насос">
        <div class="relay-description">Скважинный насос</div>
        <div class="relay-controls">
            <button type="button" onclick="sendCommandFromDiv(this)">On</button>
            <button type="button" onclick="sendCommandFromDiv(this)">Off</button>
        </div>
        <div class="relay-state">Текущее состояние: Off</div>
        <div class="relay-mode">Режим: Auto</div>
    </div>
    <div class="relay-row" data-relay="Насос давления">
        <div class="relay-description">Насос давления</div>
        <div class="relay-controls">
            <button type="button" onclick="sendCommandFromDiv(this)">On</button>
            <button type="button" onclick="sendCommandFromDiv(this)">Off</button>
        </div>
        <div class="relay-state">Текущее состояние: Off</div>
        <div class="relay-mode">Режим: Auto</div>
    </div>
    <div class="relay-row" data-relay="Насос перекачки">
        <div class="relay-description">Насос перекачки</div>
        <div class="relay-controls">
            <button type="button" onclick="sendCommandFromDiv(this)">On</button>
            <button type="button" onclick="sendCommandFromDiv(this)">Off</button>
        </div>
        <div class="relay-state">Текущее состояние: Off</div>
        <div class="relay-mode">Режим: Auto</div>
    </div>
    <div class="relay-row" data-relay="Воздушный компрессор">
        <div class="relay-description">Воздушный компрессор</div>
        <div class="relay-controls">
            <button type="button" onclick="sendCommandFromDiv(this)">On</button>
            <button type="button" onclick="sendCommandFromDiv(this)">Off</button>
        </div>
        <div class="relay-state">Текущее состояние: Off</div>
        <div class="relay-mode">Режим: Auto</div>
    </div>
    
    <div class="relay-temperature">Температура: <span id="temperature">0°C</span></div>
    
    <br>
    
    <button type="button" id="resetManual" onclick="resetAllRelaysToAuto()">Сбросить все в Auto</button>
    
    
</form>

</div>
  
   <!-- Элемент для отображения статуса -->
	<br>
    
    <button class="butScan" onclick="applySettings()" id="applySettings">Применить настройки</button>
    <button class="butScan" onclick="restartDevice()">Перезагрузить</button>
    <!-- <button class="butScan" onclick="format()">Сброс настроек</button> -->
    
  <h3 id="fileStatus">Обновить прошивку</h3>
  
<div style="margin-bottom: 20px;">
    <button id="uploadButton">Открыть файл</button>
    <button id="downloadButton">Скачать прошивку</button>
  </div>
 
  <div id="downloadLink">
    <a href="https://cloud.mail.ru/public/KtJ5/WgxbfXTrP" target="_blank">Скачать прошивку</a>
  </div>
  <div id="copyMessage">Ссылка скопирована. Подключитесь к интернету и скачайте файлы.</div>

  <input type="file" id="fileInput" style="display:none" onchange="uploadFile()">

    
    <div id="statusControl"></div> 

</form>

	
    <script>
    
    //========УПРАВЛЕНИЕ================//
    
    // Функция для отправки команды на сервер
// control.js

function resetAllRelaysToAuto() {
    fetch('/resetManual', {
        method: 'POST'
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после сброса
    })
    .catch(error => console.error('Error:', error));
}

function sendCommand(relay, action) {
	console.log('relay', relay);
		console.log('action', action);
    // Создаем объект FormData
    let formData = new FormData();
    formData.append('relay', relay);
    formData.append('action', action);

    fetch('/relay', {
        method: 'POST',
        body: formData
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после отправки команды
    })
    .catch(error => console.error('Error:', error));
}


// Функция для получения состояния реле и обновления UI
function updateStates() {
    fetch('/relayStates')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            data.relays.forEach(item => {
                // Находим соответствующий элемент с data-relay и обновляем его состояние
                const row = document.querySelector(`.relay-row[data-relay="${item.description}"]`);
                if (row) {
                    const stateElement = row.querySelector('.relay-state');
                    const modeElement = row.querySelector('.relay-mode');

                    if (stateElement) {
                        stateElement.textContent = `Текущее состояние: ${item.state ? 'On' : 'Off'}`;
                    }

                    if (modeElement) {
                        modeElement.textContent = `Режим: ${item.mode}`;
                    }
                }
            });

            // Обновление температуры
            const tempElement = document.getElementById('temperature');
            if (tempElement) {
                tempElement.textContent = `${data.temp}°C`;
            }
        })
        .catch(error => console.error('Error:', error));
}

function sendCommandFromDiv(button) {
    const row = button.closest('.relay-row');
    const relayDescription = row.querySelector('.relay-description').textContent.trim();

    // Определяем команду на основе текста кнопки
    const action = button.textContent.toLowerCase();
    
    // Отправляем команду на сервер
    sendCommand(relayDescription, action);
}

function sendCommand(relay, action) {
    let formData = new FormData();
    formData.append('relay', relay);
    formData.append('action', action);
    
    fetch('/relay', {
        method: 'POST',
        body: formData
    })
    .then(response => response.text())
    .then(text => {
        console.log(text);
        updateStates(); // Обновляем состояние после отправки команды
    })
    .catch(error => console.error('Error:', error));
}

    //==================================//

          function toggleSwitch(checkbox) {
            const labelSwitch = checkbox.nextElementSibling;
            if (checkbox.checked) {
                labelSwitch.textContent = 'ON';
               // checkbox.parentElement.previousElementSibling.disabled = false; // Включение слайдера
            } else {
                labelSwitch.textContent = 'OFF';
               // checkbox.parentElement.previousElementSibling.disabled = true; // Отключение слайдера
            }
        }

    //===========Рестрат============//
    function restartDevice() {
    fetch('/restart', {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        var statusDiv = document.getElementById("statusTelegram");
        var countdown = 10;

        statusDiv.innerHTML = `Устройство перезагружается... Подключение к серверу через ${countdown} секунд.`;
        
        var interval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
                statusDiv.innerHTML = `Устройство перезагружается... Подключение к серверу через ${countdown} секунд.`;
            } else {
                clearInterval(interval);
                statusDiv.innerHTML = "OK"; //"Подключение к серверу...";

                //checkSettingsTelegramApplied();
            }
        }, 1000);
    })
    .catch(error => {
        console.error("Error restarting device:", error);
    });
}

function format() {
    // Показать предупреждающий диалог
    if (confirm("Вы уверены, что хотите отформатировать устройство? Все данные будут удалены.")) {
        fetch('/format', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            var statusDiv = document.getElementById("statusTelegram");
            var countdown = 5;

            statusDiv.innerHTML = `Устройство форматируется... Подключение к серверу через ${countdown} секунд.`;
            
            var interval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    statusDiv.innerHTML = `Устройство форматируется... Подключение к серверу через ${countdown} секунд.`;
                } else {
                    clearInterval(interval);
                    statusDiv.innerHTML = "OK";

                }
            }, 1000);
        })
        .catch(error => {
            console.error("Ошибка перезагрузки устройства:", error);
        });
    } else {
        // Пользователь отказался от операции форматирования
        console.log("Форматирование отменено пользователем");
        // Можно добавить дополнительную логику для отмены операции
    }
}

    //==========WIFI================//
    
   let tabNameGlobal;
    
 function openTab(evt, tabName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tab");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(tabName).style.display = "block";
  evt.currentTarget.className += " active";

  // Скрыть настройки точки доступа при переключении вкладок
  tabNameGlobal = tabName;
  if (tabName !== 'WiFi') {
    document.getElementById('apSettings').classList.add('hidden');
  }
}
        document.getElementById("defaultOpen").click();
        
 let savedSettings = {}; // Переменная для хранения полученных настроек

 document.addEventListener("DOMContentLoaded", function() {

    function fetchSettings() {
        fetch('/getsettings')
            .then(response => response.json())
            .then(data => {
            //======Сеть=====//
                savedSettings = data; // Сохраняем полученные данные в переменной
                updateUI(savedSettings); // Обновляем интерфейс с полученными данными
                console.log('data', savedSettings);
            //======Телеграм=====//
            console.log("get_telegram_settings", data.telegramSettings.isTelegramOn);

        // Обновляем поля на странице с полученными данными
        document.getElementById("botId").value = data.telegramSettings.botId;
        document.getElementById("isTelegramOn").checked = data.telegramSettings.isTelegramOn || false;
        var userList = document.getElementById("userList");
        userList.innerHTML = ""; // Очищаем текущий список пользователей

		console.log('telegramUsers',data.telegramSettings.telegramUsers);
		
        data.telegramSettings.telegramUsers.forEach(user => {
            var newRow = document.createElement("tr");
            newRow.innerHTML = `
                <td>${user.id}</td>
                <td><input type="checkbox" name="read" ${user.reading ? "checked" : ""}></td>
                <td><input type="checkbox" name="control" ${user.writing ? "checked" : ""}></td>
                <td><button onclick="deleteUser('${user.id}')">Удалить</button></td>
            `;
            userList.appendChild(newRow);
        });

        if (data.telegramSettings.telegramUsers.length > 0) {
            document.getElementById("userTable").classList.remove("hidden");
        } else {
            document.getElementById("userTable").classList.add("hidden");
        }
    
            //=====================    
                
            })
            .catch(error => console.error('Ошибка при загрузке настроек:', error));
    }

	window.fetchSettings = fetchSettings;

    // Функция для обновления интерфейса с полученными настройками
    function updateUI(data) {
        document.getElementById('ap_ssid').value = data.ssidAP || '';
        document.getElementById('ap_password').value = data.passwordAP || '';
        document.getElementById('ap_ip').value = data.ipAddressAP || '';
        document.getElementById('is_ap').checked = data.isAP || false;

        let currentNetworkSetting = data.networkSettings[data.currentIdNetworkSetting];

        if (currentNetworkSetting) {
            document.getElementById('ssid').value = currentNetworkSetting.ssid || '';
            document.getElementById('password').value = currentNetworkSetting.password || '';
            document.getElementById('static_ip').value = currentNetworkSetting.staticIP || '';
            document.getElementById('gateway').value = currentNetworkSetting.staticGateway || '';
            document.getElementById('subnet').value = currentNetworkSetting.staticSubnet || '';
            document.getElementById('dns').value = currentNetworkSetting.staticDNS || '';

            if (currentNetworkSetting.useStaticIP) {
                document.getElementById('dhcp').checked = false;
                document.getElementById('static').checked = true;
            } else {
                document.getElementById('dhcp').checked = true;
                document.getElementById('static').checked = false;
            }

            console.log('currentNetworkSetting', currentNetworkSetting.staticIP);
        }

        let currentMode = data.isAP ? 'is_ap' : 'client';
        document.getElementById('currentMode').value = currentMode;

        if (data.isAP) {
            document.getElementById('clientSettings').classList.add('hidden');
            document.getElementById('apSettings').classList.remove('hidden');
            document.getElementById('scanButton').classList.add('hidden');
            document.getElementById('networks').classList.add('hidden');
            document.getElementById('staticIPSettings').classList.add('hidden');
            document.getElementById('connectForm').classList.add('hidden');

            // Устанавливаем атрибут checked для радио-кнопки is_ap
            document.getElementById('is_ap').checked = true;
        } else {
            document.getElementById('clientSettings').classList.remove('hidden');
            document.getElementById('apSettings').classList.add('hidden');
            document.getElementById('scanButton').classList.remove('hidden');
            document.getElementById('networks').classList.remove('hidden');
            document.getElementById('connectForm').classList.remove('hidden');
            // Устанавливаем атрибут checked для радио-кнопки client
            document.getElementById('client').checked = true;
        }

        if (data.connected) {
            document.getElementById('status').innerHTML = `<h2>Статус: Подключено к сети: "${currentNetworkSetting.ssid}"</h2>`;
        } else if (data.isAP) {
            document.getElementById('status').innerHTML = `<h2>Статус: Запущена точка доступа: "${data.ssidAP}"</h2>`;
        } else {
            document.getElementById('status').innerHTML = `<h2>Статус: Не подключено</h2>`;
        }

        // Вызов displayNetworks для сохраненных сетей
        displayNetworks(data.networkSettings, true);
    }

		window.updateUI = updateUI;

    // Функция для выбора сети
    function selectNetworkServer(index) {
        if (index >= 0 && index < savedSettings.networkSettings.length) {
            savedSettings.currentIdNetworkSetting = index;
            let selectedNetwork = savedSettings.networkSettings[index];
            document.getElementById('ssid').value = selectedNetwork.ssid || '';
            document.getElementById('password').value = selectedNetwork.password || '';
            document.getElementById('static_ip').value = selectedNetwork.staticIP || '';
            document.getElementById('gateway').value = selectedNetwork.staticGateway || '';
            document.getElementById('subnet').value = selectedNetwork.staticSubnet || '';
            document.getElementById('dns').value = selectedNetwork.staticDNS || '';

            console.log('selectNetworkServer', selectedNetwork);

            if (selectedNetwork.useStaticIP) {
                document.getElementById('dhcp').checked = false;
                document.getElementById('static').checked = true;
            } else {
                document.getElementById('dhcp').checked = true;
                document.getElementById('static').checked = false;
            }
            
            toggleIPMode();
        }
    }

    // Пример использования функции selectNetworkServer
    window.selectNetworkServer = selectNetworkServer;

function displayNetworks(data, saved = false) {
	console.log('displayNetworks',data);
    let networksElement = document.getElementById('networks');
    networksElement.innerHTML = saved ? '<h2>Сохраненные сети</h2>' : '<h2>Доступные сети</h2>';
    data.forEach((network, index) => {
        if (network.ssid) { // Проверка на непустой SSID
            console.log('network', network); // Debug вывод для проверки данных
            let div = document.createElement('div');
            div.innerHTML = `
                <input type="radio" name="network" value="${index}" ${savedSettings.currentIdNetworkSetting === index ? 'checked' : ''} onclick="selectNetworkServer(${index})">
                <strong>SSID:</strong> ${network.ssid}
                <button onclick="deleteNetwork('${network.ssid}')" style="color: red; margin-left: 10px;">❌</button>
            `;

            networksElement.appendChild(div);
        }
    });
}

window.displayNetworks = displayNetworks;

    // Вызываем функцию загрузки настроек при загрузке страницы
    fetchSettings();
})

function deleteNetworkOnClient(ssid) {
    console.log(`Deleting network with SSID ${ssid}`);
    
    // Поиск индекса сети с указанным SSID
    let index = savedSettings.networkSettings.findIndex(network => network.ssid === ssid);
    
    if (index !== -1) { // Проверка, найден ли элемент
        // Удаление из массива
        savedSettings.networkSettings.splice(index, 1);
        
        // Проверка, был ли удаляемый элемент выбранным
        if (savedSettings.currentIdNetworkSetting === index) {
            // Если выбранный элемент был удален, устанавливаем выбор на первый элемент
            savedSettings.currentIdNetworkSetting = 0;
        } else if (savedSettings.currentIdNetworkSetting > index) {
            // Если выбранный элемент находится после удаленного, смещаем индекс выбранного элемента на один назад
            savedSettings.currentIdNetworkSetting--;
        }
        
        // Перерисовка списка сохраненных сетей
        displayNetworks(savedSettings.networkSettings, true);
    } else {
        console.log(`Network with SSID ${ssid} not found`);
    }
}

// Функция для удаления сети по индексу
function deleteNetwork(ssid) {
    var formData = new FormData();
    formData.append('ssid', ssid);
    
    console.log('SSD to delete:', ssid);

    fetch('/deleteNetwork', {
        method: 'POST', // Изменяем метод на POST
        body: formData
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            console.log('Network deleted successfully');
            // Обновление списка сетей на клиенте
           // fetchSettings(); // Предполагаем, что у вас есть функция для загрузки настроек с сервера
           deleteNetworkOnClient(ssid);
        } else {
            console.error('Error deleting network:', data.message);
            alert('Failed to delete network');
        }
    })
    .catch(error => {
        console.error('Error deleting network:', error);
        alert('Failed to delete network');
    });
}


// Функция для переключения режима
function toggleMode() {
    var mode = document.querySelector('input[name="mode"]:checked').value;
    if (mode === 'client') {
        document.getElementById('clientSettings').classList.remove('hidden');
        document.getElementById('apSettings').classList.add('hidden');
        document.getElementById('scanButton').classList.remove('hidden');
        document.getElementById('networks').classList.remove('hidden');

    } else {
        document.getElementById('clientSettings').classList.add('hidden');
        document.getElementById('apSettings').classList.remove('hidden');
        document.getElementById('scanButton').classList.add('hidden');
        document.getElementById('networks').classList.add('hidden');
        document.getElementById('staticIPSettings').classList.add('hidden');
    }
}

        function toggleIPMode() {
            var ipMode = document.querySelector('input[name="ip_mode"]:checked').value;
            if (ipMode === 'static') {
                document.getElementById('staticIPSettings').classList.remove('hidden');
            } else {
                document.getElementById('staticIPSettings').classList.add('hidden');
            }
        }

 let isScanning = false;

 function scanWiFi() {
   fetch('/scan', { method: 'POST' })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            isScanning = true;
        })
        .catch(error => {
            console.error("Error starting WiFi scan:", error);
        });

    var status = document.getElementById('status'); 
    var tmp_status = status.textContent;

    // Начинаем обратный отсчет сразу после отправки запроса
    var countdown = 5;
    var interval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            status.innerHTML = `<h2>Поиск сетей WIFI... ${countdown} сек.</h2>`;
        } else {
            clearInterval(interval);
            status.innerHTML = `<h2>${tmp_status}</h2>`;
        }
    }, 1000);
}
    

    function displayNetworksScan(data) {
    console.log('NetworksScan', data);
        networks.innerHTML = '<h2>Доступные сети</h2>';
        data.forEach(network => {
            let div = document.createElement('div');
            div.innerHTML = `
                <input type="radio" name="network" value="${network.ssid}" onclick="selectNetwork('${network.ssid}')">
                <strong>SSID:</strong> ${network.ssid} <strong>RSSI:</strong> ${network.rssi}
            `;
            networks.appendChild(div);
        });
    }


    function checkForNetworks() {
    if (!isScanning) return;

    fetch('/getNetworks')
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                isScanning = false;
                displayNetworksScan(data);
                document.getElementById('status').innerHTML = "<h2>Сети WIFI найдены</h2>";
            }
        })
        .catch(error => {
            console.error("Error checking for networks:", error);
        });
	}
    
      function selectNetwork(ssid) {
      
   // const networkExists = savedSettings.networkSettings.some(network => network.ssid === ssid);

    //if (!networkExists) {
     document.getElementById('dhcp').checked = true;
      document.getElementById('static').checked = false;
      document.getElementById('staticIPSettings').classList.add('hidden');
    //}

      console.log('selectNetwork', ssid);
        document.getElementById('ssid').value = ssid;
        document.getElementById('connectForm').style.display = 'block';      
      }
  
function applySettings() {

 var statusDiv = document.getElementById("status");

 var isTelegramOn = document.getElementById("isTelegramOn").checked;
    var botId = document.getElementById("botId").value;
    var userList = document.getElementById("userList");
    var rows = userList.getElementsByTagName("tr");
    var users = [];

    for (var i = 0; i < rows.length; i++) {
        var userId = rows[i].cells[0].innerText;
        var reading = rows[i].querySelector("input[name='read']").checked;
        var writing = rows[i].querySelector("input[name='control']").checked;
        users.push({ id: userId, reading: reading, writing: writing });
    }

//=================================
    let mode = document.querySelector('input[name="mode"]:checked').value;
    let currentMode = document.getElementById('currentMode').value;

    let valid = true;

    // Проверка IP адреса
    function validateIP(ip) {
        let parts = ip.split('.');
        if (parts.length !== 4) return false;
        for (let i = 0; i < parts.length; i++) {
            let num = parseInt(parts[i]);
            if (isNaN(num) || num < 0 || num > 255) return false;
        }
        return true;
    }

    // Проверка пароля
    function validatePassword(password) {
        return password.length >= 8;
    }

    // Сброс состояния ошибок
    function resetErrorState(element) {
        element.style.borderColor = '';
    }

    // Установка состояния ошибок
    function setErrorState(element) {
        element.style.borderColor = 'red';
        valid = false;
    }

    let formData = new FormData();
    formData.append('mode', mode);
    
    formData.append('isTelegramOn', isTelegramOn.toString());
    formData.append('botId', botId);
    formData.append('users', JSON.stringify(users));

    for (var pair of formData.entries()) {
       console.log(pair[0] + ': ' + pair[1]);
    }

    if (mode === 'client') {
        let ssid = document.getElementById('ssid').value;
        let password = document.getElementById('password').value;
        let ipMode = document.querySelector('input[name="ip_mode"]:checked').value;
        let selectedNetworkIndex = savedSettings.currentIdNetworkSetting; // Индекс выбранной сети

        if (ssid.trim() === '') {
            setErrorState(document.getElementById('ssid'));
        } else {
            formData.append('ssid', ssid);
            resetErrorState(document.getElementById('ssid'));
        }

        if (false) { // !validatePassword(password)
            setErrorState(document.getElementById('password'));
        } else {
            formData.append('password', password);
            resetErrorState(document.getElementById('password'));
        }

        if (ipMode === 'static') {
            let static_ip = document.getElementById('static_ip').value;
            let gateway = document.getElementById('gateway').value;
            let subnet = document.getElementById('subnet').value;
            let dns = document.getElementById('dns').value;

            if (!validateIP(static_ip)) {
                setErrorState(document.getElementById('static_ip'));
            } else {
                formData.append('static_ip', static_ip);
                resetErrorState(document.getElementById('static_ip'));
            }

            if (!validateIP(gateway)) {
                setErrorState(document.getElementById('gateway'));
            } else {
                formData.append('gateway', gateway);
                resetErrorState(document.getElementById('gateway'));
            }

            if (!validateIP(subnet)) {
                setErrorState(document.getElementById('subnet'));
            } else {
                formData.append('subnet', subnet);
                resetErrorState(document.getElementById('subnet'));
            }

            if (!validateIP(dns)) {
                setErrorState(document.getElementById('dns'));
            } else {
                formData.append('dns', dns);
                resetErrorState(document.getElementById('dns'));
            }
        }

        formData.append('ip_mode', ipMode);
        formData.append('selectedNetworkIndex', selectedNetworkIndex); // Добавляем индекс выбранной сети

    } else {
        let ap_ssid = document.getElementById('ap_ssid').value;
        let ap_password = document.getElementById('ap_password').value;
        let ap_ip = document.getElementById('ap_ip').value;
        let isAP = document.getElementById('is_ap').checked;

        if (ap_ssid.trim() === '') {
            setErrorState(document.getElementById('ap_ssid'));
        } else {
            formData.append('ap_ssid', ap_ssid);
            resetErrorState(document.getElementById('ap_ssid'));
        }

        if (ap_password.trim() !== '' && !validatePassword(ap_password)) {
            setErrorState(document.getElementById('ap_password'));
        } else if (ap_password.trim() !== '') {
            formData.append('ap_password', ap_password);
            resetErrorState(document.getElementById('ap_password'));
        }

        if (ap_ip.trim() !== '' && !validateIP(ap_ip)) {
            setErrorState(document.getElementById('ap_ip'));
        } else if (ap_ip.trim() !== '') {
            formData.append('ap_ip', ap_ip);
            resetErrorState(document.getElementById('ap_ip'));
        }

        formData.append('is_ap', isAP);
    }

    if (valid) {
    	
    	 statusDiv.innerHTML = "Сохранение...";
    
        handleModeChange(mode);

        fetch('/applySettings', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {

       			 statusDiv.innerHTML = "<br>Настройки успешно сохранены. Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
                
                // if (tabNameGlobal === 'WiFi') {
//                 	var statusDiv = document.getElementById("status");
//        					 statusDiv.innerHTML = data.message + "<br>Настройки успешно сохранены. Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
//                 		//updateUI(savedSettings); // Обновляем интерфейс с новыми данными
//                 } else 
//                 	if (tabNameGlobal === 'Telegram') {
//                		  var statusDiv = document.getElementById("statusTelegram");
//        					 statusDiv.innerHTML = data.message + "<br>Чтобы изменения вступили в силу, необходимо перезагрузить устройство.";
//        			 } else 
//                 	if (tabNameGlobal === 'Control') {
//                 		console.log('Selected control tab');
//                 	}
                	
            } else {
                statusDiv.innerHTML = "Ошибка при сохранении настроек!";
            }
        })
        .catch(error => {
            console.error('Ошибка при применении настроек:', error);
            // Обработка смены режима при ошибке
            handleModeChange(mode);
        });
    } else {
        alert('Пожалуйста, исправьте ошибки в форме.');
    }

    function handleModeChange(mode) {
        if (currentMode !== mode) {
            if (mode === 'is_ap') {
                let ap_ssid = document.getElementById('ap_ssid').value;
                document.getElementById('status').innerHTML = `<h2>Статус: Режим работы Wi-Fi изменен. Пожалуйста, переподключитесь к точке доступа: "${ap_ssid}".</h2>`;
            } else {
                let ssid = document.getElementById('ssid').value;
                document.getElementById('status').innerHTML = `<h2>Статус: Режим работы Wi-Fi изменен. Пожалуйста, переподключитесь к Wi-Fi сети: "${ssid}".</h2>`;
            }
            currentMode = mode;
        }
    }
}
//============

document.getElementById('uploadButton').addEventListener('click', function() {
        document.getElementById('fileInput').click(); // Имитация клика по input
    });

    document.getElementById('downloadButton').addEventListener('click', function() {
        var downloadLink = document.getElementById('downloadLink');
        var copyMessage = document.getElementById('copyMessage');
        downloadLink.style.display = 'block';
        copyMessage.style.display = 'block';

        // Копирование ссылки в буфер обмена
        var dummy = document.createElement('input');
        document.body.appendChild(dummy);
        dummy.setAttribute('value', downloadLink.getElementsByTagName('a')[0].href);
        dummy.select();
        document.execCommand('copy');
        document.body.removeChild(dummy);
    });


function uploadFile() {
        var statusHeader = document.getElementById('fileStatus');
        statusHeader.textContent = "Загрузка файла..."; // Статус перед началом загрузки

        var fileInput = document.getElementById('fileInput');
        var file = fileInput.files[0];
        var formData = new FormData();
        formData.append('file', file);

        var fileName = file.name;
        var extension = fileName.substring(fileName.lastIndexOf('.') + 1);

        if (extension === "bin") {
            var countdown = 8;
            statusHeader.textContent = `Обновление... ${countdown} секунд осталось`; // Статус перед успешной загрузкой и начала обновления
            var interval = setInterval(function() {
                countdown--;
                if (countdown > 0) {
                    statusHeader.textContent = `Обновление... ${countdown} секунд осталось`;
                } else {
                    clearInterval(interval);
                    statusHeader.textContent = "Переподключитесь к устройству"; // Сообщение о переподключении
                    setTimeout(function() {
                    checkServerAndReload();
                        
                    }, 3000); // 3 секунды для переподключения
                }
            }, 1000); // Таймер на 1 секунду
        }

        fetch('/uploadFile', {
            method: 'POST',
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.text();
        })
        .then(data => {
            if (extension !== "bin") {
                statusHeader.textContent = "Успешно"; // Статус после успешной загрузки
                location.reload();
            }
        })
        .catch((error) => {
        if (extension !== "bin") {
            console.error('Ошибка:', error);
            statusHeader.textContent = "Ошибка загрузки"; // Статус при ошибке загрузки
            }
        });
    }
    
    function checkServerAndReload() {
        fetch('/', { method: 'HEAD' })
            .then(response => {
                if (response.ok) {
                    location.reload();
                } else {
                    console.error('Сервер недоступен');
                }
            })
            .catch(error => {
                console.error('Ошибка подключения к серверу:', error);
            });
		}
////==========ТЕЛЕГРАМ=============////

function validateBotId(botId) {
    // Регулярное выражение для проверки допустимых символов
    const regex = /^[a-zA-Z0-9_\-:!@#$%^&*()+=<>?]+$/;
    return regex.test(botId);
}


function setBotId() {
    var botId = document.getElementById("botId").value;

    if (!validateBotId(botId)) {
        console.log(botId);
        var statusDiv = document.getElementById("statusTelegram");
        statusDiv.innerHTML = "Invalid Bot ID. Please use only allowed characters.";
        alert("Invalid Bot ID. Please use only allowed characters."); 
        return;
    }

    let formData = new FormData();
    formData.append('botId', botId);
    
    fetch('/set_bot_id', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
//         var statusDiv = document.getElementById("statusTelegram");
//         statusDiv.innerHTML = data.message;

        // Вывод имени бота
        if (data.botName) {
                    var botNameDiv = document.getElementById("statusTelegram");
                    var cleanBotName = data.botName.trim(); // Удаление пробелов

						botNameDiv.textContent = "Bot Name: @" + data.botName;
                }
    })
    .catch(error => {
        console.error("Error:", error);
    });
}


function addUser() {
    var userId = document.getElementById("userId").value;
    // Проверка на пустое поле пользователя
    if (!userId) {
        alert("Введите идентификатор пользователя!");
        return;
    }

    // Проверка на уникальность пользователя
    var userList = document.getElementById("userList");
    var rows = userList.getElementsByTagName("tr");
    for (var i = 0; i < rows.length; i++) {
        if (rows[i].cells[0].innerText === userId) {
            alert("Пользователь с таким идентификатором уже существует!");
            return;
        }
    }

    // Создаем строки таблицы с флажками по умолчанию
    var newRow = document.createElement("tr");
    newRow.innerHTML = `
        <td>${userId}</td>
        <td><input type="checkbox" name="read" checked></td>
        <td><input type="checkbox" name="control" checked></td>
        <td><button onclick="deleteUser('${userId}')">Удалить</button></td>
    `;
    userList.appendChild(newRow);

    document.getElementById("userTable").classList.remove("hidden");

    // Создаем объект FormData и отправляем данные на сервер
    let formData = new FormData();
    formData.append('user_id', userId);
    formData.append('reading', true);
    formData.append('writing', true);

    fetch('/add_user', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        document.getElementById("statusTelegram").innerHTML = data.message;
    })
    .catch(error => {
        console.error('Error adding user:', error);
    });
}

function deleteUser(userId) {
    let formData = new FormData();
    formData.append('user_id', userId);

    fetch('/delete_user', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        console.log('Response from server:', data);

        if (data.success) {
            document.getElementById("statusTelegram").innerHTML = data.message;

            // Ищем строку с указанным userId и удаляем её
            var userList = document.getElementById("userList");
            var rows = userList.getElementsByTagName("tr");
            for (var i = 0; i < rows.length; i++) {
                if (rows[i].cells[0].innerText == userId) {
                    userList.removeChild(rows[i]);
                    break;
                }
            }

            // Проверяем, есть ли еще пользователи после удаления
            if (userList.getElementsByTagName("tr").length === 0) {
                document.getElementById("userTable").classList.add("hidden");
            }
        } else {
            console.error('Server returned error:', data.message);
        }
    })
    .catch(error => {
        console.error('Error deleting user:', error);
    });

    // Предотвращаем переключение на дефолтную вкладку
    event.preventDefault();
}

//=====================
 async function getStatus() {
      try {
        const response = await fetch('/sysStatus'); // Отправляем GET запрос к серверу
        if (!response.ok) throw new Error('Network response was not ok');
        const status = await response.text(); // Получаем текст ответа
        showModal(status); // Отображаем статус в алерте
        // Или можно использовать модальное окно вместо алерта
        // showModal(status); 
      } catch (error) {
        console.error('Ошибка:', error);
        alert('Не удалось получить статус системы.');
      }
    }

    // Функция для отображения статуса в модальном окне
    function showModal(status) {
  // Преобразование символов переноса строки в теги <br>
  const htmlStatus = status.replace(/\n/g, '<br>');

  const modal = document.createElement('div');
  modal.style.position = 'fixed';
  modal.style.top = '50%';
  modal.style.left = '50%';
  modal.style.transform = 'translate(-50%, -50%)';
  modal.style.backgroundColor = 'white';
  modal.style.border = '1px solid black';
  modal.style.padding = '20px';
  modal.style.zIndex = '1000';

  const text = document.createElement('p');
  text.innerHTML = htmlStatus;  // Используем innerHTML для вставки HTML
  modal.appendChild(text);

  const closeButton = document.createElement('button');
  closeButton.textContent = 'Закрыть';
  closeButton.onclick = () => document.body.removeChild(modal);
  modal.appendChild(closeButton);

  document.body.appendChild(modal);
}


document.addEventListener('DOMContentLoaded', () => {
 	updateStates();
    setInterval(updateStates, 1000);

    setInterval(checkForNetworks, 1000);
});
//ver2.3
// получение сертификата openssl s_client -showcerts -connect api.telegram.org:443 </dev/null 2>/dev/null | openssl x509 -outform PEM > api_telegram_org.pem 
    </script>
    
    <input type="hidden" id="currentMode" value="">
  </body>
  </html>